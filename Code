"""
Tobias Bot Pro - Sistema Avan√ßado de Transcri√ß√£o de V√≠deos do YouTube

Este m√≥dulo fornece uma classe principal para transcri√ß√£o autom√°tica
de v√≠deos do YouTube usando IA (Faster Whisper) com interface moderna.

Autor: [SEU NOME]
Vers√£o: 2.0.0
Licen√ßa: MIT
"""

import os
import re
import torch
import logging
from typing import Optional, List
import subprocess
import sys

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class TobiasBotPro:
    """
    Sistema avan√ßado para transcri√ß√£o de v√≠deos do YouTube.
    
    Combina download inteligente com processamento de √°udio e transcri√ß√£o
    usando modelos de IA de √∫ltima gera√ß√£o.
    
    Attributes:
        model: Modelo Faster Whisper carregado
        device: Dispositivo de processamento (cuda/cpu)
        model_size: Tamanho do modelo ('tiny', 'base', 'small', 'medium', 'large')
    
    Example:
        >>> bot = TobiasBotPro()
        >>> texto = bot.process_video("https://youtube.com/watch?v=VIDEO_ID")
        >>> print(texto)
    """
    
    def __init__(self, model_size: str = "base", device: str = "auto"):
        """
        Inicializa o Tobias Bot Pro.
        
        Args:
            model_size: Tamanho do modelo Whisper
            device: Dispositivo ('cuda', 'cpu', 'auto')
        """
        self.model_size = model_size
        self.device = self._detect_device(device)
        self.compute_type = "float16" if self.device == "cuda" else "int8"
        self.model = None
        
        logger.info("ü§ñ Inicializando Tobias Bot Pro...")
        self._setup_model()
        
    def _detect_device(self, device: str) -> str:
        """Detecta o melhor dispositivo dispon√≠vel."""
        if device == "auto":
            return "cuda" if torch.cuda.is_available() else "cpu"
        return device
    
    def _setup_model(self) -> bool:
        """Carrega o modelo Faster Whisper."""
        try:
            from faster_whisper import WhisperModel
            
            logger.info(f"üß† Carregando modelo {self.model_size} ({self.device})...")
            
            self.model = WhisperModel(
                self.model_size,
                device=self.device,
                compute_type=self.compute_type
            )
            
            logger.info("‚úÖ Modelo carregado com sucesso!")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao carregar modelo: {e}")
            return False
    
    def validate_youtube_url(self, url: str) -> Optional[str]:
        """
        Valida e normaliza URL do YouTube.
        
        Args:
            url: URL para validar
            
        Returns:
            URL normalizada ou None se inv√°lida
        """
        patterns = [
            r'(?:https?://)?(?:www\.)?youtube\.com/watch\?v=([a-zA-Z0-9_-]+)',
            r'(?:https?://)?(?:www\.)?youtu\.be/([a-zA-Z0-9_-]+)',
            r'(?:https?://)?(?:m\.)?youtube\.com/watch\?v=([a-zA-Z0-9_-]+)',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                video_id = match.group(1)
                return f"https://www.youtube.com/watch?v={video_id}"
        
        return None
    
    def download_video(self, url: str) -> Optional[str]:
        """
        Baixa v√≠deo usando m√∫ltiplas estrat√©gias.
        
        Args:
            url: URL do v√≠deo
            
        Returns:
            Caminho do arquivo de √°udio ou None
        """
        clean_url = self.validate_youtube_url(url)
        if not clean_url:
            logger.error("‚ùå URL inv√°lida")
            return None
        
        logger.info(f"üîó Processando: {clean_url}")
        
        # Tentar yt-dlp primeiro
        audio_file = self._download_with_ydl(clean_url)
        if audio_file:
            return audio_file
        
        # Tentar pytube como backup
        audio_file = self._download_with_pytube(clean_url)
        if audio_file:
            return audio_file
        
        logger.error("‚ùå Todas as estrat√©gias falharam")
        return None
    
    def _download_with_ydl(self, url: str) -> Optional[str]:
        """Download usando yt-dlp com m√∫ltiplas configura√ß√µes."""
        try:
            import yt_dlp
            
            configs = [
                # Configura√ß√£o b√°sica
                {
                    'format': 'bestaudio[ext=m4a]/bestaudio',
                    'outtmpl': 'audio_%(id)s.%(ext)s',
                    'postprocessors': [{
                        'key': 'FFmpegExtractAudio',
                        'preferredcodec': 'wav',
                        'preferredquality': '128',
                    }],
                },
                # Configura√ß√£o com headers mobile
                {
                    'format': 'worst[ext=mp4]/worst',
                    'outtmpl': 'audio_%(id)s.%(ext)s',
                    'postprocessors': [{
                        'key': 'FFmpegExtractAudio',
                        'preferredcodec': 'wav',
                        'preferredquality': '96',
                    }],
                    'http_headers': {
                        'User-Agent': 'Mozilla/5.0 (Linux; Android 11) AppleWebKit/537.36'
                    },
                    'extractor_args': {
                        'youtube': {'player_client': ['android']}
                    },
                }
            ]
            
            for i, config in enumerate(configs, 1):
                try:
                    logger.info(f"üì• Tentativa {i} com yt-dlp...")
                    with yt_dlp.YoutubeDL(config) as ydl:
                        info = ydl.extract_info(url, download=True)
                        return self._find_audio_file(info['id'])
                except Exception as e:
                    logger.warning(f"Tentativa {i} falhou: {str(e)[:50]}...")
                    continue
                    
        except ImportError:
            logger.error("yt-dlp n√£o encontrado")
        
        return None
    
    def _download_with_pytube(self, url: str) -> Optional[str]:
        """Download usando pytube como backup."""
        try:
            from pytube import YouTube
            
            logger.info("üì• Tentando com pytube...")
            yt = YouTube(url)
            
            # Pegar stream de √°udio
            audio_stream = yt.streams.filter(only_audio=True).first()
            if not audio_stream:
                return None
            
            # Download
            filename = f"audio_{yt.video_id}.mp4"
            audio_stream.download(filename=filename)
            
            # Converter para WAV
            wav_file = f"audio_{yt.video_id}.wav"
            if self._convert_to_wav(filename, wav_file):
                os.remove(filename)
                return wav_file
            
            return filename
            
        except Exception as e:
            logger.warning(f"Pytube falhou: {e}")
        
        return None
    
    def _find_audio_file(self, video_id: str) -> Optional[str]:
        """Encontra arquivo de √°udio baixado."""
        extensions = ['.wav', '.m4a', '.mp3', '.webm', '.mp4']
        
        for ext in extensions:
            filename = f"audio_{video_id}{ext}"
            if os.path.exists(filename):
                # Converter para WAV se necess√°rio
                if ext != '.wav':
                    wav_file = f"audio_{video_id}.wav"
                    if self._convert_to_wav(filename, wav_file):
                        os.remove(filename)
                        return wav_file
                
                return filename
        
        return None
    
    def _convert_to_wav(self, input_file: str, output_file: str) -> bool:
        """Converte arquivo para formato WAV."""
        try:
            subprocess.run([
                'ffmpeg', '-i', input_file, '-ar', '16000',
                '-ac', '1', '-c:a', 'pcm_s16le', output_file, '-y'
            ], capture_output=True, check=True)
            return True
        except:
            return False
    
    def transcribe_audio(self, audio_file: str) -> Optional[str]:
        """
        Transcreve arquivo de √°udio para texto.
        
        Args:
            audio_file: Caminho do arquivo de √°udio
            
        Returns:
            Texto transcrito ou None
        """
        if not self.model:
            logger.error("‚ùå Modelo n√£o carregado")
            return None
        
        if not os.path.exists(audio_file):
            logger.error(f"‚ùå Arquivo n√£o encontrado: {audio_file}")
            return None
        
        try:
            logger.info("üéØ Iniciando transcri√ß√£o...")
            
            segments, info = self.model.transcribe(audio_file, language="pt")
            
            logger.info(f"üìä Idioma: {info.language} "
                       f"(confian√ßa: {info.language_probability:.2f})")
            
            # Processar segmentos
            full_text = ""
            segment_count = 0
            
            for segment in segments:
                full_text += segment.text + " "
                segment_count += 1
                
                if segment_count % 10 == 0:
                    logger.info(f"   üìù {segment_count} segmentos processados...")
            
            logger.info(f"‚úÖ Transcri√ß√£o conclu√≠da! ({segment_count} segmentos)")
            return full_text.strip()
            
        except Exception as e:
            logger.error(f"‚ùå Erro na transcri√ß√£o: {e}")
            return None
    
    def process_video(self, url: str) -> Optional[str]:
        """
        Processa v√≠deo completo: download + transcri√ß√£o.
        
        Args:
            url: URL do v√≠deo do YouTube
            
        Returns:
            Texto transcrito ou None
        """
        logger.info("üöÄ PROCESSANDO V√çDEO")
        logger.info("=" * 40)
        
        try:
            # 1. Download
            audio_file = self.download_video(url)
            if not audio_file:
                return None
            
            # 2. Transcri√ß√£o
            transcription = self.transcribe_audio(audio_file)
            
            # 3. Limpeza
            self._cleanup_files(audio_file)
            
            logger.info("‚úÖ PROCESSAMENTO CONCLU√çDO!")
            return transcription
            
        except Exception as e:
            logger.error(f"‚ùå Erro cr√≠tico: {e}")
            return None
    
    def _cleanup_files(self, *files: str) -> None:
        """Remove arquivos tempor√°rios."""
        for file_path in files:
            try:
                if os.path.exists(file_path):
                    os.remove(file_path)
                    logger.info(f"üßπ Removido: {file_path}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è N√£o foi poss√≠vel remover {file_path}: {e}")


# Fun√ß√µes utilit√°rias
def test_url(url: str) -> bool:
    """Testa uma URL do YouTube rapidamente."""
    try:
        import yt_dlp
        
        bot = TobiasBotPro()
        clean_url = bot.validate_youtube_url(url)
        
        if not clean_url:
            print("‚ùå URL inv√°lida")
            return False
        
        print(f"‚úÖ URL v√°lida: {clean_url}")
        
        # Testar acesso
        with yt_dlp.YoutubeDL({'quiet': True}) as ydl:
            info = ydl.extract_info(clean_url, download=False)
            print(f"üé¨ T√≠tulo: {info.get('title', 'N/A')}")
            print(f"‚è±Ô∏è Dura√ß√£o: {info.get('duration', 'N/A')}s")
            return True
            
    except Exception as e:
        print(f"‚ùå Erro: {e}")
        return False


def fix_youtube_403():
    """Corrige problemas de erro 403 do YouTube."""
    print("üîß Aplicando corre√ß√µes para erro 403...")
    
    try:
        subprocess.check_call([
            sys.executable, "-m", "pip", "install", "--upgrade", "yt-dlp"
        ])
        print("‚úÖ yt-dlp atualizado com sucesso")
    except Exception as e:
        print(f"‚ùå Erro na atualiza√ß√£o: {e}")


def main():
    """Fun√ß√£o principal para uso via linha de comando."""
    if len(sys.argv) != 2:
        print("Uso: python tobias_bot.py <URL_DO_YOUTUBE>")
        print("Exemplo: python tobias_bot.py https://youtube.com/watch?v=dQw4w9WgXcQ")
        sys.exit(1)
    
    url = sys.argv[1]
    
    print("ü§ñ Tobias Bot Pro - Transcri√ß√£o via Terminal")
    print("=" * 50)
    
    # Criar e usar bot
    bot = TobiasBotPro()
    
    if not bot.model:
        print("‚ùå Erro na inicializa√ß√£o do modelo")
        sys.exit(1)
    
    # Processar v√≠deo
    transcricao = bot.process_video(url)
    
    if transcricao:
        print("\nüìù TRANSCRI√á√ÉO:")
        print("=" * 50)
        print(transcricao)
        
        # Salvar em arquivo
        filename = "transcricao.txt"
        with open(filename, "w", encoding="utf-8") as f:
            f.write(transcricao)
        print(f"\nüíæ Salvo em: {filename}")
    else:
        print("‚ùå Falha na transcri√ß√£o")
        sys.exit(1)


if __name__ == "__main__":
    main()
